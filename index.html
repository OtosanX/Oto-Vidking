<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vidking Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --bg: #050810;
      --bg-alt: #0c1020;
      --card-bg: #111827;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.25);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --radius-lg: 1rem;
      --radius-sm: 0.5rem;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 55%);
      color: var(--text);
    }

    body.theater {
      background: #000;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1.25rem 1rem 2.5rem;
    }

    body.theater .page {
      max-width: none;
      padding: 0;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      margin-bottom: 1rem;
    }

    @media (min-width: 700px) {
      header {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
      }
    }

    .title-block h1 {
      margin: 0 0 0.2rem;
      font-size: 1.8rem;
      letter-spacing: 0.05em;
    }

    .title-block p {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .nav {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }

    .nav-btn {
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--muted);
      font-size: 0.85rem;
      cursor: pointer;
    }

    .nav-btn.active {
      border-color: var(--accent);
      color: #dbeafe;
      background: rgba(37,99,235,0.3);
    }

    .controls {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .search-input {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.45rem 0.7rem;
      border-radius: 999px;
      font-size: 0.9rem;
      min-width: 190px;
      outline: none;
    }

    .search-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .select-input {
      background: var(--bg-alt);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.45rem 0.7rem;
      border-radius: 999px;
      font-size: 0.9rem;
      min-width: 150px;
      outline: none;
    }

    .section { display: none; }
    .section.active { display: block; }

    .section-title-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 0.5rem;
      margin-top: 0.75rem;
    }

    .section-title-row h2 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .section-title-row span {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .card-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .item-card {
      width: 150px;
      border-radius: 0.9rem;
      background: linear-gradient(145deg, var(--card-bg), #020617);
      border: 1px solid var(--border);
      padding: 0.4rem;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      box-shadow: 0 12px 30px rgba(0,0,0,0.4);
    }

    .card-actions {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }

    .card-actions .btn {
      flex: 1 1 100%;
      text-align: center;
      padding: 0.35rem 0.5rem;
    }

    .card-actions .btn.subtle {
      color: #cbd5e1;
      border-color: rgba(148,163,184,0.35);
    }

    .item-card:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .item-poster {
      width: 100%;
      border-radius: 0.7rem;
      overflow: hidden;
      background: #020617;
      aspect-ratio: 2 / 3;
    }

    .item-poster img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .item-title {
      font-size: 0.85rem;
      font-weight: 500;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .item-meta {
      font-size: 0.75rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 0.35rem;
    }

    .pill-small {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 0.1rem 0.45rem;
      font-size: 0.7rem;
      color: var(--muted);
      background: rgba(15,23,42,0.8);
    }

    /* PLAYER PAGE */

    #playerSectionWrapper {
      background: radial-gradient(circle at top, #020617, #000);
      padding: 1rem;
      border-radius: 1.1rem;
      border: 1px solid var(--border);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
    }

    body.theater #playerSectionWrapper {
      border-radius: 0;
      border: none;
      box-shadow: none;
      padding: 0.5rem;
    }

    #playerTopRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    #playerTopRow h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .player-actions {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--muted);
      padding: 0.35rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .btn.primary {
      border-color: var(--accent);
      color: #dbeafe;
      background: rgba(37,99,235,0.25);
    }

    .player-wrapper {
      position: relative;
      width: 100%;
      /* 16:9 aspect ratio that works on older browsers (Android TV) */
      padding-top: 56.25%;
      max-height: calc(100vh - 220px);
      border-radius: var(--radius-sm);
      overflow: hidden;
      background: #000;
      margin-bottom: 0.75rem;
    }

    .player-wrapper.is-sized {
      padding-top: 0;
    }

    body.theater .player-wrapper {
      position: relative;
      width: 100%;
      /* same 16:9 ratio in theater mode */
      padding-top: 56.25%;
      max-height: calc(100vh - 120px);
      border-radius: 0;
      margin: 0 auto 0.75rem;
    }

    body.theater .player-wrapper.is-sized {
      padding-top: 0;
    }

    .player-wrapper iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    #playerBottomRow {
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 2.3fr);
      gap: 0.75rem;
    }

    @media (max-width: 900px) {
      #playerBottomRow {
        grid-template-columns: minmax(0,1fr);
      }
    }

    #descriptionPanel,
    #episodePanel {
      background: linear-gradient(145deg, var(--card-bg), #020617);
      border-radius: 0.9rem;
      border: 1px solid var(--border);
      padding: 0.75rem;
    }

    #descriptionPanel h3,
    #episodePanel h3 {
      margin: 0 0 0.4rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    #descriptionText {
      font-size: 0.85rem;
      color: var(--muted);
    }

    #descMeta {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 0.4rem;
    }

    #episodeList {
      max-height: 260px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      font-size: 0.8rem;
    }

    .episode-row {
      display: flex;
      justify-content: space-between;
      gap: 0.4rem;
      padding: 0.25rem 0.5rem;
      border-radius: 0.5rem;
      cursor: pointer;
      border: 1px solid transparent;
      background: rgba(15,23,42,0.85);
    }

    .episode-row:hover {
      border-color: var(--border);
    }

    .episode-row.active {
      border-color: var(--accent);
      background: rgba(37,99,235,0.25);
    }

    .episode-title {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .episode-meta {
      color: var(--muted);
      margin-left: 0.25rem;
    }

    /* TMDb search panel */

    .tmdb-panel {
      margin-top: 1.25rem;
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, #111827, #020617);
    }

    .tmdb-header {
      margin: 0 0 0.5rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .tmdb-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .tmdb-input {
      flex: 1 1 220px;
      background: #0b1020;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.5rem 0.75rem;
      color: var(--text);
      font-size: 0.9rem;
      outline: none;
    }

    .tmdb-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .tmdb-button {
      border-radius: 999px;
      padding: 0.5rem 0.9rem;
      border: 1px solid #2563eb;
      background: rgba(37, 99, 235, 0.22);
      color: #dbeafe;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .tmdb-status {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    .tmdb-results {
      max-height: 260px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .tmdb-result-row {
      display: flex;
      gap: 0.5rem;
      padding: 0.4rem 0.55rem;
      border-radius: 0.6rem;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
    }

    .tmdb-poster-wrap {
      flex: 0 0 40px;
      height: 60px;
      border-radius: 0.4rem;
      overflow: hidden;
      background: #020617;
    }

    .tmdb-poster-wrap img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .tmdb-body {
      flex: 1;
      min-width: 0;
    }

    .tmdb-title {
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 0.2rem;
    }

    .tmdb-meta {
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 0.2rem;
    }

    .tmdb-overview {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .tmdb-actions {
      margin-top: 0.3rem;
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    footer {
      margin-top: 1.4rem;
      font-size: 0.75rem;
      color: var(--muted);
      text-align: center;
    }

    body.theater header,
    body.theater .tmdb-panel,
    body.theater footer,
    body.theater #homeSection,
    body.theater #librarySection {
      display: none !important;
    }

    body.theater #playerSection {
      padding-top: 0.4rem;
    }

    /* DEVICE ADAPTIVE STYLES */
    body.mobile .page {
      max-width: none;
      padding: 0.75rem 0.65rem 1.6rem;
    }

    body.mobile header {
      gap: 0.4rem;
    }

    body.mobile .controls {
      width: 100%;
      justify-content: space-between;
      gap: 0.4rem;
    }

    body.mobile .search-input,
    body.mobile .select-input {
      flex: 1 1 0;
      min-width: 0;
      font-size: 0.95rem;
      padding: 0.55rem 0.7rem;
    }

    body.mobile .nav-btn,
    body.mobile .btn {
      padding: 0.55rem 0.85rem;
      font-size: 0.95rem;
    }

    body.mobile .item-card {
      width: clamp(150px, 44vw, 220px);
    }

    body.mobile .card-row {
      justify-content: center;
    }

    body.tv .page {
      max-width: 1400px;
      padding: 1.1rem 1rem 2rem;
    }

    body.tv .nav-btn,
    body.tv .btn {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      letter-spacing: 0.02em;
    }

    body.tv .title-block h1 {
      font-size: 2rem;
    }

    body.tv .controls {
      gap: 0.8rem;
    }

    body.tv .search-input,
    body.tv .select-input {
      font-size: 1rem;
      padding: 0.6rem 0.85rem;
    }

    body.tv .card-row {
      justify-content: center;
      gap: 1rem;
    }

    body.tv .item-card {
      width: 180px;
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div class="title-block">
        <h1>Vidking Hub</h1>
        <p>Home, library & player for our Vidking setup.</p>
        <div class="nav">
          <button class="nav-btn active" data-route="home">Home</button>
          <button class="nav-btn" data-route="search">Search</button>
          <button class="nav-btn" data-route="library">Library</button>
        </div>
      </div>
      <div class="controls">
        <input
          id="searchInput"
          class="search-input"
          type="search"
          placeholder="Search my library…"
        />
        <select id="filterSelect" class="select-input">
          <option value="all">All types</option>
          <option value="movie">Movies</option>
          <option value="tv">Shows</option>
          <option value="watchlist">Watchlist</option>
        </select>
      </div>
    </header>

    <!-- SEARCH SECTION -->
    <section id="searchSection" class="section">
      <section class="tmdb-panel">
        <h2 class="tmdb-header">Search Results</h2>
        <div class="tmdb-row">
          <input
            id="tmdbSearchInput"
            class="tmdb-input"
            type="search"
            placeholder="Search TMDb (movie / show)…"
          />
          <button id="tmdbSearchButton" class="tmdb-button" type="button">
            Search
          </button>
        </div>
        <div id="tmdbStatus" class="tmdb-status">
          Type a title above and click Search.
        </div>
        <div id="tmdbResults" class="tmdb-results"></div>
      </section>
    </section>

    <!-- HOME SECTION -->
    <section id="homeSection" class="section active">
      <div class="section-title-row">
        <h2>Continue Watching</h2>
        <span id="continueCount"></span>
      </div>
      <div id="continueRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>My Watchlist</h2>
        <span id="watchlistCount"></span>
      </div>
      <div id="watchlistRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>Popular Movies (region)</h2>
        <span id="popularMoviesLabel"></span>
      </div>
      <div id="popularMoviesRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>Popular Shows (region)</h2>
        <span id="popularTvLabel"></span>
      </div>
      <div id="popularTvRow" class="card-row"></div>
    </section>

    <!-- LIBRARY SECTION -->
    <section id="librarySection" class="section">
      <div class="section-title-row">
        <h2>My Watchlist (library)</h2>
        <span id="libraryWatchlistCount"></span>
      </div>
      <div id="libraryWatchlistRow" class="card-row"></div>

      <div class="section-title-row">
        <h2>My Library</h2>
        <span id="libraryCount"></span>
      </div>
      <div id="libraryRow" class="card-row"></div>
    </section>

    <!-- PLAYER SECTION -->
    <section id="playerSection" class="section">
      <div id="playerSectionWrapper">
        <div id="playerTopRow">
          <h2 id="playerTitle">Nothing playing</h2>
          <div class="player-actions">
            <button id="backHomeBtn" class="btn">← Back</button>
            <button id="watchlistToggleBtn" class="btn">Add to watchlist</button>
            <button id="castBtn" class="btn">Cast</button>
            <button id="theaterBtn" class="btn primary">Theater mode</button>
          </div>
        </div>

        <div class="player-wrapper" id="playerContainer"></div>

        <div id="playerBottomRow">
          <div id="descriptionPanel">
            <h3>Details</h3>
            <div id="descriptionText">Pick something from Home or Library to play.</div>
            <div id="descMeta"></div>
          </div>
          <div id="episodePanel">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;margin-bottom:0.25rem;">
              <h3 style="margin:0;">Episodes</h3>
              <select id="seasonSelect" class="select-input" style="max-width:160px;">
                <option value="1">Season 1</option>
              </select>
            </div>
            <div id="episodeList">No episodes (movies won’t show a list).</div>
          </div>
        </div>
      </div>
    </section>

    <footer>
      Data is stored locally in this browser using localStorage.
    </footer>
  </div>

  <script>
    /******************************************************************
     * CONFIG
     ******************************************************************/
    const TMDB_API_KEY = "d89facea7c73a78ab167ef244381a9ee"; // your key
    const TMDB_API_BASE = "https://api.themoviedb.org/3";
    const TMDB_IMG_BASE = "https://image.tmdb.org/t/p/w300";
    const TMDB_THUMB_BASE = "https://image.tmdb.org/t/p/w92";
    const REGION = "US";
    const STORAGE_KEY = "vidkingHubLibraryV1";
    const CAST_SDK_URL =
      "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";

    let library = [];
    let popularMovies = [];
    let popularTv = [];
    let currentItem = null;
    let currentSeason = 1;
    let currentEpisode = 1;
    let episodesCache = {};
    let currentRoute = "home";
    let playerSrcWatcher = null;
    let lastPlayerSrc = "";
    let lastAutoAdvanceKey = null;
    let isCasting = false;
    let castContext = null;
    let castSession = null;
    let castMedia = null;
    let castInitPromise = null;

    /******************************************************************
     * STORAGE HELPERS
     ******************************************************************/
    function saveLibrary() {
      try {
        const data = JSON.stringify(library);
        localStorage.setItem(STORAGE_KEY, data);
      } catch (e) {
        console.warn("Could not save library:", e);
      }
    }

    function loadLibraryFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
          library = parsed;
        }
      } catch (e) {
        console.warn("Could not load library:", e);
      }
    }

    /******************************************************************
     * DOM
     ******************************************************************/
    const routeButtons = document.querySelectorAll(".nav-btn");
    const homeSection = document.getElementById("homeSection");
    const searchSection = document.getElementById("searchSection");
    const librarySection = document.getElementById("librarySection");
    const playerSection = document.getElementById("playerSection");

    const continueRow = document.getElementById("continueRow");
    const watchlistRow = document.getElementById("watchlistRow");
    const continueCount = document.getElementById("continueCount");
    const watchlistCount = document.getElementById("watchlistCount");
    const popularMoviesRow = document.getElementById("popularMoviesRow");
    const popularTvRow = document.getElementById("popularTvRow");
    const popularMoviesLabel = document.getElementById("popularMoviesLabel");
    const popularTvLabel = document.getElementById("popularTvLabel");

    const libraryRow = document.getElementById("libraryRow");
    const libraryCount = document.getElementById("libraryCount");
    const libraryWatchlistRow = document.getElementById("libraryWatchlistRow");
    const libraryWatchlistCount = document.getElementById("libraryWatchlistCount");

    const searchInput = document.getElementById("searchInput");
    const filterSelect = document.getElementById("filterSelect");

    const tmdbSearchInput = document.getElementById("tmdbSearchInput");
    const tmdbSearchButton = document.getElementById("tmdbSearchButton");
    const tmdbStatusEl = document.getElementById("tmdbStatus");
    const tmdbResultsEl = document.getElementById("tmdbResults");

    const playerTitle = document.getElementById("playerTitle");
    const playerContainer = document.getElementById("playerContainer");
    const descriptionText = document.getElementById("descriptionText");
    const descMeta = document.getElementById("descMeta");
    const episodeList = document.getElementById("episodeList");
    const seasonSelect = document.getElementById("seasonSelect");
    const backHomeBtn = document.getElementById("backHomeBtn");
    const watchlistToggleBtn = document.getElementById("watchlistToggleBtn");
    const castBtn = document.getElementById("castBtn");
    const theaterBtn = document.getElementById("theaterBtn");

    /******************************************************************
     * ROUTING
     ******************************************************************/
    function setRoute(route) {
      const leavingPlayer = currentRoute === "player" && route !== "player";

      if (leavingPlayer) {
        // clear iframe so Vidking stops audio
        stopPlayerWatcher();
        playerContainer.innerHTML = "";
        document.body.classList.remove("theater");
        theaterBtn.textContent = "Theater mode";
      }

      currentRoute = route;

      homeSection.classList.remove("active");
      searchSection.classList.remove("active");
      librarySection.classList.remove("active");
      playerSection.classList.remove("active");

      routeButtons.forEach((b) =>
        b.classList.toggle("active", b.dataset.route === route)
      );

      if (route === "home") homeSection.classList.add("active");
      if (route === "search") searchSection.classList.add("active");
      if (route === "library") librarySection.classList.add("active");
      if (route === "player") playerSection.classList.add("active");

      if (route === "player") {
        resizePlayerWrapper();
      }
    }

    routeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setRoute(btn.dataset.route);
        if (btn.dataset.route === "library") {
          renderLibrary();
        } else if (btn.dataset.route === "search") {
          tmdbSearchInput?.focus();
        }
      });
    });

    window.addEventListener("resize", resizePlayerWrapper);

    /******************************************************************
     * LIBRARY / STATE HELPERS
     ******************************************************************/
    function findInLibraryByTmdb(type, tmdbId) {
      return library.find((x) => x.type === type && String(x.tmdbId) === String(tmdbId));
    }

    function addToLibraryFromTmdbResult(result, isMovie, { makeWatchlist = false } = {}) {
      const tmdbId = result.id;
      const existing = findInLibraryByTmdb(isMovie ? "movie" : "tv", tmdbId);
      if (existing) {
        if (makeWatchlist && !existing.isWatchlist) {
          existing.isWatchlist = true;
          saveLibrary();
          renderHome();
          renderLibrary();
        }
        return existing;
      }

      const title = isMovie ? result.title : result.name;
      const date = isMovie ? result.release_date : result.first_air_date;
      const year = date ? date.slice(0, 4) : "";
      const overview = result.overview || "";
      const poster = result.poster_path
        ? TMDB_IMG_BASE + result.poster_path
        : "";

      const item = {
        id: `${isMovie ? "movie" : "tv"}-${tmdbId}-${Date.now()}`,
        tmdbId,
        type: isMovie ? "movie" : "tv",
        title,
        year,
        overview,
        poster,
        addedAt: Date.now(),
        lastWatchedAt: 0,
        isWatchlist: !!makeWatchlist,
        lastSeason: 1,
        lastEpisode: 0,
        lastProgress: 0,
        lastPosition: 0,
        lastDuration: 0
      };

      library.push(item);
      saveLibrary();
      renderLibrary();
      renderHome();
      return item;
    }

    function markWatched(item) {
      item.lastWatchedAt = Date.now();
      saveLibrary();
      renderHome();
    }

    function toggleWatchlist(item) {
      item.isWatchlist = !item.isWatchlist;
      saveLibrary();
      renderHome();
      renderLibrary();
      updateWatchlistButton();
    }

    function removeFromLibrary(item) {
      const idx = library.findIndex((x) => x.id === item.id);
      if (idx === -1) return;

      library.splice(idx, 1);
      if (currentItem && currentItem.id === item.id) {
        currentItem = null;
        playerContainer.innerHTML = "";
        renderPlayerDetails();
      }

      saveLibrary();
      renderHome();
      renderLibrary();
    }

    /******************************************************************
     * CARD RENDERING
     ******************************************************************/
    function makeCard(item, opts = {}) {
      const div = document.createElement("div");
      div.className = "item-card";

      const posterWrap = document.createElement("div");
      posterWrap.className = "item-poster";
      if (item.poster) {
        const img = document.createElement("img");
        img.src = item.poster;
        img.alt = item.title;
        posterWrap.appendChild(img);
      }
      div.appendChild(posterWrap);

      const titleEl = document.createElement("div");
      titleEl.className = "item-title";
      titleEl.textContent = item.title;
      div.appendChild(titleEl);

      const metaEl = document.createElement("div");
      metaEl.className = "item-meta";
      const left = document.createElement("span");
      left.textContent =
        (item.type === "movie" ? "Movie" : "Show") +
        (item.year ? " • " + item.year : "");
      const right = document.createElement("span");
      right.textContent = opts.rightLabel || "";
      metaEl.appendChild(left);
      metaEl.appendChild(right);
      div.appendChild(metaEl);

      if (opts.showWatchlistPill && item.isWatchlist) {
        const pill = document.createElement("div");
        pill.className = "pill-small";
        pill.textContent = "Watchlist";
        div.appendChild(pill);
      }

      if (opts.showActions) {
        const actionsWrap = document.createElement("div");
        actionsWrap.className = "card-actions";

        const wlBtn = document.createElement("button");
        wlBtn.className = "btn subtle";
        wlBtn.type = "button";
        const setWatchlistLabel = () => {
          wlBtn.textContent = item.isWatchlist
            ? "Remove from watchlist"
            : "Add to watchlist";
        };
        setWatchlistLabel();
        wlBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          toggleWatchlist(item);
          setWatchlistLabel();
        });
        actionsWrap.appendChild(wlBtn);

        if (opts.onRemove) {
          const removeBtn = document.createElement("button");
          removeBtn.className = "btn";
          removeBtn.type = "button";
          removeBtn.textContent = "Remove from library";
          removeBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            opts.onRemove(item);
          });
          actionsWrap.appendChild(removeBtn);
        }

        div.appendChild(actionsWrap);
      }

      div.addEventListener("click", () => {
        openPlayer(item, { fromRoute: opts.fromRoute || "home" });
      });

      return div;
    }

    /******************************************************************
     * HOME RENDERING
     ******************************************************************/
    function renderHome() {
      const cont = [...library]
        .filter((x) => x.lastWatchedAt)
        .sort((a, b) => b.lastWatchedAt - a.lastWatchedAt)
        .slice(0, 12);

      continueRow.innerHTML = "";
      continueCount.textContent = cont.length ? `${cont.length} items` : "None";
      cont.forEach((item) => {
        const label =
          item.type === "tv" && item.lastSeason && item.lastEpisode
            ? `S${String(item.lastSeason).padStart(2, "0")}E${String(
                item.lastEpisode
              ).padStart(2, "0")}`
            : "Continue";
        const card = makeCard(item, {
          rightLabel: label,
          showWatchlistPill: true,
          fromRoute: "home"
        });
        continueRow.appendChild(card);
      });

      const wl = library.filter((x) => x.isWatchlist);
      watchlistRow.innerHTML = "";
      watchlistCount.textContent = wl.length ? `${wl.length} items` : "None";
      wl.slice(0, 12).forEach((item) => {
        const card = makeCard(item, {
          rightLabel: "Watchlist",
          showWatchlistPill: true,
          fromRoute: "home"
        });
        watchlistRow.appendChild(card);
      });

      popularMoviesRow.innerHTML = "";
      popularMoviesLabel.textContent = popularMovies.length
        ? `${popularMovies.length} from TMDb`
        : "";
      popularMovies.slice(0, 12).forEach((r) => {
        const temp = {
          type: "movie",
          tmdbId: r.id,
          title: r.title,
          year: (r.release_date || "").slice(0, 4),
          overview: r.overview || "",
          poster: r.poster_path ? TMDB_IMG_BASE + r.poster_path : ""
        };
        const card = makeCard(temp, {
          rightLabel: "Popular",
          fromRoute: "home"
        });
        popularMoviesRow.appendChild(card);
      });

      popularTvRow.innerHTML = "";
      popularTvLabel.textContent = popularTv.length
        ? `${popularTv.length} from TMDb`
        : "";
      popularTv.slice(0, 12).forEach((r) => {
        const temp = {
          type: "tv",
          tmdbId: r.id,
          title: r.name,
          year: (r.first_air_date || "").slice(0, 4),
          overview: r.overview || "",
          poster: r.poster_path ? TMDB_IMG_BASE + r.poster_path : ""
        };
        const card = makeCard(temp, {
          rightLabel: "Popular",
          fromRoute: "home"
        });
        popularTvRow.appendChild(card);
      });
    }

    /******************************************************************
     * LIBRARY RENDERING
     ******************************************************************/
    function renderLibrary() {
      const term = searchInput.value.trim().toLowerCase();
      const filter = filterSelect.value;

      let watchlistItems = library.filter((x) => x.isWatchlist);
      if (filter === "movie") watchlistItems = watchlistItems.filter((x) => x.type === "movie");
      if (filter === "tv") watchlistItems = watchlistItems.filter((x) => x.type === "tv");

      if (term) {
        watchlistItems = watchlistItems.filter((x) =>
          (x.title + " " + x.overview).toLowerCase().includes(term)
        );
      }
      libraryWatchlistRow.innerHTML = "";
      libraryWatchlistCount.textContent = watchlistItems.length
        ? `${watchlistItems.length} items`
        : "None";

      watchlistItems
        .sort((a, b) => b.addedAt - a.addedAt)
        .forEach((item) => {
          const card = makeCard(item, {
            rightLabel: "Watchlist",
            showWatchlistPill: true,
            fromRoute: "library",
            showActions: true,
            onRemove: removeFromLibrary
          });
          libraryWatchlistRow.appendChild(card);
        });

      let list = [...library];

      if (filter === "movie") list = list.filter((x) => x.type === "movie");
      if (filter === "tv") list = list.filter((x) => x.type === "tv");
      if (filter === "watchlist") list = list.filter((x) => x.isWatchlist);

      if (term) {
        list = list.filter((x) =>
          (x.title + " " + x.overview).toLowerCase().includes(term)
        );
      }

      libraryRow.innerHTML = "";
      libraryCount.textContent = list.length
        ? `${list.length} items`
        : "Empty";

      list
        .sort((a, b) => b.addedAt - a.addedAt)
        .forEach((item) => {
          const label =
            item.type === "tv" && item.lastSeason && item.lastEpisode
              ? `S${String(item.lastSeason).padStart(2, "0")}E${String(
                  item.lastEpisode
                ).padStart(2, "0")}`
              : item.isWatchlist
              ? "Watchlist"
              : "";
          const card = makeCard(item, {
            rightLabel: label,
            showWatchlistPill: true,
            fromRoute: "library",
            showActions: true,
            onRemove: removeFromLibrary
          });
          libraryRow.appendChild(card);
        });
    }

    // search / filter always work on Library and show that tab
    searchInput.addEventListener("input", () => {
      if (currentRoute !== "library") {
        setRoute("library");
      }
      renderLibrary();
    });
    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const query = searchInput.value;
        if (tmdbSearchInput) tmdbSearchInput.value = query;
        setRoute("home");
        searchTmdb(query);
      }
    });
    filterSelect.addEventListener("change", () => {
      if (currentRoute !== "library") {
        setRoute("library");
      }
      renderLibrary();
    });

    if (seasonSelect) {
      seasonSelect.addEventListener("change", () => {
        if (!currentItem || currentItem.type !== "tv") return;
        const val = parseInt(seasonSelect.value, 10);
        if (!val || val < 1) return;
        currentSeason = val;
        currentEpisode = 1;

        const src = buildVidkingUrl(currentItem, currentSeason, currentEpisode);
        playerContainer.innerHTML = `
          <iframe
            src="${src}"
            frameborder="0"
            allow="autoplay; fullscreen"
            allowfullscreen
          ></iframe>
        `;
        resizePlayerWrapper();
        currentItem.lastSeason = currentSeason;
        currentItem.lastEpisode = currentEpisode;
        markWatched(currentItem);
        renderPlayerDetails();
        startPlayerWatcher();
        pushCastIfActive(true);
      });
    }

    /******************************************************************
     * PLAYER
     ******************************************************************/
    function buildVidkingUrl(item, season = 1, episode = 1, options = {}) {
      const autoplayParams = "autoPlay=true";
      if (item.type === "movie") {
        return `https://www.vidking.net/embed/movie/${item.tmdbId}?${autoplayParams}`;
      }

      const base = `https://www.vidking.net/embed/tv/${item.tmdbId}/${season}/${episode}`;
      const params = [autoplayParams, "episodeSelector=true"];
      if (isCasting || options.forceEmbedAutonext) {
        params.push("nextEpisode=true");
      }
      return `${base}?${params.join("&")}`;
    }

    function getAvailablePlayerHeight() {
      const basePadding = document.body.classList.contains("theater") ? 120 : 220;
      return Math.max(200, window.innerHeight - basePadding);
    }

    function resizePlayerWrapper() {
      if (!playerContainer) return;
      const rect = playerContainer.getBoundingClientRect();
      const width = rect.width || playerContainer.clientWidth || window.innerWidth;
      const desiredHeight = width * (9 / 16);
      const availableHeight = getAvailablePlayerHeight();
      const finalHeight = Math.min(
        Number.isFinite(desiredHeight) && desiredHeight > 0 ? desiredHeight : availableHeight,
        availableHeight
      );

      playerContainer.classList.add("is-sized");
      playerContainer.style.height = `${finalHeight}px`;
      playerContainer.style.maxHeight = `${availableHeight}px`;
    }

    function stopPlayerWatcher() {
      if (playerSrcWatcher) {
        clearInterval(playerSrcWatcher);
        playerSrcWatcher = null;
      }
    }

    function syncEpisodeFromSrc(src) {
      const match = src.match(/\/tv\/(\d+)\/(\d+)\/(\d+)/);
      if (!match || !currentItem) return;

      const [, tmdbId, seasonStr, epStr] = match;
      if (String(tmdbId) !== String(currentItem.tmdbId)) return;

      const parsedSeason = parseInt(seasonStr, 10);
      const parsedEpisode = parseInt(epStr, 10);
      if (Number.isFinite(parsedSeason)) currentSeason = parsedSeason;
      if (Number.isFinite(parsedEpisode)) currentEpisode = parsedEpisode;

      currentItem.lastSeason = currentSeason;
      currentItem.lastEpisode = currentEpisode;
      markWatched(currentItem);
      renderEpisodeList(currentItem, currentSeason, currentEpisode);
      renderPlayerDetails();
    }

    function startPlayerWatcher() {
      stopPlayerWatcher();
      const iframe = playerContainer.querySelector("iframe");
      if (!iframe) return;
      lastPlayerSrc = iframe.getAttribute("src") || "";
      if (lastPlayerSrc) syncEpisodeFromSrc(lastPlayerSrc);

      playerSrcWatcher = setInterval(() => {
        const src = iframe.getAttribute("src") || "";
        if (src && src !== lastPlayerSrc) {
          lastPlayerSrc = src;
          syncEpisodeFromSrc(src);
        }
      }, 1500);
    }

    /******************************************************************
     * CASTING
     ******************************************************************/
    function loadCastSdk() {
      if (castInitPromise) return castInitPromise;

      castInitPromise = new Promise((resolve, reject) => {
        if (window.cast && window.cast.framework) {
          resolve();
          return;
        }

        const script = document.createElement("script");
        script.src = CAST_SDK_URL;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = (err) => reject(err);
        document.head.appendChild(script);
      });

      return castInitPromise;
    }

    async function setupCasting() {
      if (!castBtn) return;
      castBtn.disabled = true;

      try {
        await loadCastSdk();
        if (!(window.cast && window.cast.framework)) {
          throw new Error("Cast SDK not available");
        }

        castContext = cast.framework.CastContext.getInstance();
        castContext.setOptions({
          receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
          autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
        });

        castBtn.disabled = false;
        castBtn.title = "Cast to a wireless device";
        castBtn.addEventListener("click", onCastButtonClick);

        castContext.addEventListener(
          cast.framework.CastContextEventType.SESSION_STATE_CHANGED,
          handleCastSessionState
        );
      } catch (e) {
        console.warn("Casting unavailable", e);
        castBtn.textContent = "Cast unavailable";
      }
    }

    async function onCastButtonClick() {
      if (!castContext) return;

      if (isCasting && castSession) {
        castSession.endSession(true);
        return;
      }

      try {
        await castContext.requestSession();
      } catch (e) {
        console.warn("Cast request failed", e);
      }
    }

    function handleCastSessionState(event) {
      if (!event || !castContext) return;
      const state = event.sessionState;

      if (
        state === cast.framework.SessionState.SESSION_STARTED ||
        state === cast.framework.SessionState.SESSION_RESUMED
      ) {
        castSession = castContext.getCurrentSession();
        isCasting = true;
        castBtn.textContent = "Casting…";
        castBtn.classList.add("primary");
        syncCastMediaToCurrent(true);
      } else if (
        state === cast.framework.SessionState.SESSION_ENDING ||
        state === cast.framework.SessionState.SESSION_ENDED ||
        state === cast.framework.SessionState.SESSION_START_FAILED ||
        state === cast.framework.SessionState.NO_SESSION
      ) {
        isCasting = false;
        castMedia = null;
        castSession = null;
        castBtn.textContent = "Cast";
        castBtn.classList.remove("primary");
      }
    }

    function onCastMediaUpdate(isAlive) {
      if (!isAlive || !castMedia) return;

      if (
        castMedia.playerState === chrome.cast.media.PlayerState.IDLE &&
        castMedia.idleReason === chrome.cast.media.IdleReason.FINISHED &&
        currentItem &&
        currentItem.type === "tv"
      ) {
        autoAdvanceEpisode(currentItem, currentSeason, currentEpisode);
        syncCastMediaToCurrent(true);
      }
    }

    function syncCastMediaToCurrent(forceAutonext = false) {
      if (!isCasting || !castSession || !currentItem) return;
      if (!(window.chrome && chrome.cast && chrome.cast.media)) return;

      const src = buildVidkingUrl(currentItem, currentSeason, currentEpisode, {
        forceEmbedAutonext: forceAutonext
      });

      const mediaInfo = new chrome.cast.media.MediaInfo(src, "text/html");
      mediaInfo.metadata = new chrome.cast.media.GenericMediaMetadata();
      mediaInfo.metadata.title = currentItem.title || "Vidking";
      if (currentItem.type === "tv") {
        mediaInfo.metadata.subtitle =
          "S" +
          String(currentSeason).padStart(2, "0") +
          "E" +
          String(currentEpisode).padStart(2, "0");
      } else if (currentItem.year) {
        mediaInfo.metadata.subtitle = String(currentItem.year);
      }
      mediaInfo.customData = {
        tmdbId: currentItem.tmdbId,
        type: currentItem.type,
        season: currentSeason,
        episode: currentEpisode
      };

      const request = new chrome.cast.media.LoadRequest(mediaInfo);
      request.autoplay = true;

      castSession
        .loadMedia(request)
        .then((media) => {
          castMedia = media;
          if (castMedia) {
            castMedia.addUpdateListener(onCastMediaUpdate);
          }
        })
        .catch((err) => console.warn("Cast load failed", err));
    }

    function pushCastIfActive(forceAutonext = false) {
      if (!isCasting || !castSession) return;
      syncCastMediaToCurrent(forceAutonext);
    }

    function detectDevice() {
      const ua = navigator.userAgent || "";
      const isAndroidTv = /Android TV|BRAVIA|SMART-TV|HbbTV|NETTV/i.test(ua);
      const isMobile = !isAndroidTv && /Mobi|Android|iPhone|iPad|iPod/i.test(ua);

      if (isMobile) {
        document.body.classList.add("mobile");
      }
    }

    function updateWatchlistButton() {
      if (!currentItem) return;
      watchlistToggleBtn.textContent = currentItem.isWatchlist
        ? "Remove from watchlist"
        : "Add to watchlist";
    }

    function renderPlayerDetails() {
      if (!currentItem) {
        playerTitle.textContent = "Nothing playing";
        descriptionText.textContent =
          "Pick something from Home or Library to play.";
        descMeta.textContent = "";
        episodeList.innerHTML = "No episodes.";
        if (seasonSelect) seasonSelect.style.display = "none";
        return;
      }

      playerTitle.textContent = currentItem.title;
      descriptionText.textContent = currentItem.overview || "No description.";
      descMeta.textContent =
        (currentItem.type === "movie" ? "Movie" : "Show") +
        (currentItem.year ? " • " + currentItem.year : "") +
        (currentItem.type === "tv"
          ? ` • Season ${currentSeason}, Episode ${currentEpisode}`
          : "");

      if (currentItem.type === "movie") {
        episodeList.innerHTML =
          "Movies don’t show episodes. Use the player controls above.";
        if (seasonSelect) seasonSelect.style.display = "none";
      } else {
        if (seasonSelect) {
          seasonSelect.style.display = "inline-block";
          seasonSelect.value = String(currentSeason);
        }
        loadSeasons(currentItem);
        renderEpisodeList(currentItem, currentSeason, currentEpisode);
      }

      updateWatchlistButton();
    }

    async function loadSeasons(item) {
      if (!seasonSelect || item.type !== "tv") return;
      if (!TMDB_API_KEY || TMDB_API_KEY === "REPLACE_WITH_YOUR_TMDB_KEY") return;

      try {
        const url =
          `${TMDB_API_BASE}/tv/${item.tmdbId}` +
          `?api_key=${encodeURIComponent(TMDB_API_KEY)}&language=en-US`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        const seasons = (data.seasons || [])
          .filter((s) => s.season_number > 0)
          .sort((a, b) => a.season_number - b.season_number);

        seasonSelect.innerHTML = "";
        seasons.forEach((s) => {
          const opt = document.createElement("option");
          opt.value = s.season_number;
          opt.textContent = `Season ${s.season_number}`;
          seasonSelect.appendChild(opt);
        });

        if (seasons.some((s) => s.season_number === currentSeason)) {
          seasonSelect.value = String(currentSeason);
        } else if (seasons.length) {
          currentSeason = seasons[0].season_number;
          seasonSelect.value = String(currentSeason);
        }
      } catch (e) {
        console.error("loadSeasons error", e);
      }
    }

    async function loadEpisodes(item, season) {
      const key = `${item.tmdbId}-s${season}`;
      if (episodesCache[key]) return episodesCache[key];

      if (!TMDB_API_KEY || TMDB_API_KEY === "REPLACE_WITH_YOUR_TMDB_KEY") {
        return [];
      }

      const url =
        `${TMDB_API_BASE}/tv/${item.tmdbId}/season/${season}` +
        `?api_key=${encodeURIComponent(TMDB_API_KEY)}&language=en-US`;
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        const eps = data.episodes || [];
        episodesCache[key] = eps;
        return eps;
      } catch (e) {
        console.error(e);
        return [];
      }
    }

    async function renderEpisodeList(item, season, activeEpisode) {
      episodeList.innerHTML = "Loading episodes…";
      const eps = await loadEpisodes(item, season);
      if (!eps.length) {
        episodeList.innerHTML = "No episodes from TMDb.";
        return;
      }

      episodeList.innerHTML = "";
      eps.forEach((ep) => {
        const row = document.createElement("div");
        row.className =
          "episode-row" +
          (ep.episode_number === activeEpisode ? " active" : "");
        const left = document.createElement("div");
        left.className = "episode-title";
        const epCode =
          "S" +
          String(season).padStart(2, "0") +
          "E" +
          String(ep.episode_number).padStart(2, "0");
        left.textContent =
          epCode + " – " + (ep.name || "Episode " + ep.episode_number);
        const right = document.createElement("div");
        right.className = "episode-meta";
        right.textContent =
          (ep.runtime ? ep.runtime + " min" : "") ||
          (ep.air_date ? ep.air_date : "");

        row.appendChild(left);
        row.appendChild(right);

        row.addEventListener("click", () => {
          currentSeason = season;
          currentEpisode = ep.episode_number;
          const src = buildVidkingUrl(item, currentSeason, currentEpisode);
          playerContainer.innerHTML = `
            <iframe
              src="${src}"
              frameborder="0"
              allow="autoplay; fullscreen"
              allowfullscreen
            ></iframe>
          `;
          resizePlayerWrapper();
          item.lastSeason = currentSeason;
          item.lastEpisode = currentEpisode;
          markWatched(item);
          renderPlayerDetails();
          startPlayerWatcher();
          pushCastIfActive(true);
        });

        episodeList.appendChild(row);
      });
    }

    function autoAdvanceEpisode(item, season, episode) {
      if (!item || item.type !== "tv") return;
      const s = Number(season) || 1;
      const e = Number(episode) || 1;

      const key = `${item.type}-${item.tmdbId}-s${s}-e${e}`;
      // Prevent double-triggering on repeated events from the same episode
      if (lastAutoAdvanceKey === key) return;
      lastAutoAdvanceKey = key;

      (async () => {
        const eps = await loadEpisodes(item, s);
        if (!eps.length) return;

        const idx = eps.findIndex((ep) => ep.episode_number === e);
        if (idx === -1 || idx === eps.length - 1) {
          // Last episode in the season → don’t auto-jump to next season for now
          return;
        }

        const nextEpNum = eps[idx + 1].episode_number;

        currentItem = item;
        currentSeason = s;
        currentEpisode = nextEpNum;

        const src = buildVidkingUrl(item, currentSeason, currentEpisode);
        playerContainer.innerHTML = `
          <iframe
            src="${src}"
            frameborder="0"
            allow="autoplay; fullscreen"
            allowfullscreen
          ></iframe>
        `;

        resizePlayerWrapper();
        item.lastSeason = currentSeason;
        item.lastEpisode = currentEpisode;
        markWatched(item);
        renderPlayerDetails();
        pushCastIfActive(true);
      })();
    }

    function openPlayer(item, { fromRoute }) {
      currentItem = item;

      if (item.type === "tv") {
        currentSeason = item.lastSeason || 1;
        currentEpisode = item.lastEpisode || 1;
        if (currentEpisode < 1) currentEpisode = 1;
      } else {
        currentSeason = 1;
        currentEpisode = 1;
      }

      const src = buildVidkingUrl(item, currentSeason, currentEpisode);
      playerContainer.innerHTML = `
        <iframe
          src="${src}"
          frameborder="0"
          allow="autoplay; fullscreen"
          allowfullscreen
        ></iframe>
      `;

      resizePlayerWrapper();
      markWatched(item);
      renderPlayerDetails();
      startPlayerWatcher();
      pushCastIfActive(true);
      setRoute("player");
      window.scrollTo({ top: 0, behavior: "smooth" });

      backHomeBtn.dataset.backRoute = fromRoute || "home";
    }

    backHomeBtn.addEventListener("click", () => {
      document.body.classList.remove("theater");
      theaterBtn.textContent = "Theater mode";
      const route = backHomeBtn.dataset.backRoute || "home";
      setRoute(route);
    });

    watchlistToggleBtn.addEventListener("click", () => {
      if (!currentItem) return;
      toggleWatchlist(currentItem);
    });

    theaterBtn.addEventListener("click", () => {
      document.body.classList.toggle("theater");
      theaterBtn.textContent = document.body.classList.contains("theater")
        ? "Exit theater"
        : "Theater mode";
      resizePlayerWrapper();
    });

    /******************************************************************
     * VIDKING WATCH PROGRESS EVENTS
     ******************************************************************/
    function handlePlayerMessage(event) {
      if (typeof event.data !== "string") return;

      let payload;
      try {
        payload = JSON.parse(event.data);
      } catch {
        return;
      }

      let info = null;

      // New format: { type: "PLAYER_EVENT", data: {...} }
      if (payload && payload.type === "PLAYER_EVENT" && payload.data) {
        info = payload.data;
      }
      // Older/simple format directly carrying id/mediaType/etc.
      else if (payload && payload.id && (payload.mediaType || payload.type)) {
        info = {
          id: payload.id,
          mediaType: payload.mediaType || payload.type,
          progress: payload.progress,
          currentTime: payload.currentTime ?? payload.timestamp,
          duration: payload.duration,
          season: payload.season,
          episode: payload.episode
        };
      }

      if (!info || !info.id || !info.mediaType) return;

      const mediaType = info.mediaType === "tv" ? "tv" : "movie";
      const tmdbId = String(info.id);
      const eventType = info.eventType || info.type || null;

      const item = library.find(
        (x) => x.type === mediaType && String(x.tmdbId) === tmdbId
      );
      if (!item) return;

      // Update watch progress
      item.lastWatchedAt = Date.now();
      if (typeof info.progress === "number") item.lastProgress = info.progress;
      if (typeof info.currentTime === "number")
        item.lastPosition = info.currentTime;
      if (typeof info.duration === "number")
        item.lastDuration = info.duration;

      if (mediaType === "tv") {
        if (info.season) item.lastSeason = info.season;
        if (info.episode) item.lastEpisode = info.episode;
      }

      // Decide if this episode is effectively finished
      const progress = typeof info.progress === "number" ? info.progress : null;
      const duration = typeof info.duration === "number" ? info.duration : null;
      const currentTime =
        typeof info.currentTime === "number"
          ? info.currentTime
          : typeof info.timestamp === "number"
          ? info.timestamp
          : null;

      const nearEndByProgress = progress !== null && progress >= 98;
      const nearEndByTime =
        duration !== null &&
        currentTime !== null &&
        duration > 0 &&
        duration - currentTime <= 5; // within 5 seconds of the end

      const isTv = mediaType === "tv";
      const hasEpisodeInfo = info.season != null && info.episode != null;

      // Prefer the explicit "ended" event, but also handle platforms that never fire it
      if (
        isTv &&
        hasEpisodeInfo &&
        (
          eventType === "ended" ||
          eventType === "timeupdate" && (nearEndByProgress || nearEndByTime)
        )
      ) {
        autoAdvanceEpisode(item, info.season, info.episode);
      }

      saveLibrary();
      renderHome();
      renderLibrary();
    }

    window.addEventListener("message", handlePlayerMessage);

    /******************************************************************
     * TMDb SEARCH
     ******************************************************************/
    async function searchTmdb(query) {
      const q = query.trim();
      setRoute("search");

      if (!q) {
        tmdbStatusEl.textContent = "Type a title to search TMDb.";
        tmdbResultsEl.innerHTML = "";
        return;
      }

      if (!TMDB_API_KEY || TMDB_API_KEY === "REPLACE_WITH_YOUR_TMDB_KEY") {
        tmdbStatusEl.textContent =
          "TMDb API key missing. Edit index.html and set TMDB_API_KEY.";
        return;
      }

      window.scrollTo({ top: 0, behavior: "smooth" });
      tmdbStatusEl.textContent = "Searching TMDb…";
      tmdbResultsEl.innerHTML = "";

      try {
        const url =
          `${TMDB_API_BASE}/search/multi?api_key=${encodeURIComponent(
            TMDB_API_KEY
          )}&language=en-US&include_adult=false&query=${encodeURIComponent(q)}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        const results = (data.results || []).filter((r) =>
          ["movie", "tv"].includes(r.media_type)
        );
        if (!results.length) {
          tmdbStatusEl.textContent = "No results.";
          return;
        }
        tmdbStatusEl.textContent =
          "Found " +
          results.length +
          " result" +
          (results.length === 1 ? "" : "s") +
          ". Click to add.";
        renderTmdbResults(results.slice(0, 20));
      } catch (e) {
        console.error(e);
        tmdbStatusEl.textContent = "Error talking to TMDb.";
      }
    }

    function renderTmdbResults(results) {
      tmdbResultsEl.innerHTML = "";
      results.forEach((r) => {
        const isMovie = r.media_type === "movie";
        const row = document.createElement("div");
        row.className = "tmdb-result-row";

        const posterWrap = document.createElement("div");
        posterWrap.className = "tmdb-poster-wrap";
        if (r.poster_path) {
          const img = document.createElement("img");
          img.src = TMDB_THUMB_BASE + r.poster_path;
          img.alt = isMovie ? r.title : r.name;
          posterWrap.appendChild(img);
        }
        row.appendChild(posterWrap);

        const body = document.createElement("div");
        body.className = "tmdb-body";

        const titleEl = document.createElement("div");
        titleEl.className = "tmdb-title";
        const title = isMovie ? r.title : r.name;
        const date = isMovie ? r.release_date : r.first_air_date;
        const year = date ? date.slice(0, 4) : "";
        titleEl.textContent = title + (year ? " (" + year + ")" : "");
        body.appendChild(titleEl);

        const metaEl = document.createElement("div");
        metaEl.className = "tmdb-meta";
        metaEl.textContent =
          (isMovie ? "Movie" : "Show") + " • TMDb #" + r.id;
        body.appendChild(metaEl);

        const overviewEl = document.createElement("div");
        overviewEl.className = "tmdb-overview";
        const ov = r.overview || "";
        overviewEl.textContent =
          ov.length > 140 ? ov.slice(0, 137) + "…" : ov;
        body.appendChild(overviewEl);

        const actions = document.createElement("div");
        actions.className = "tmdb-actions";

        const addBtn = document.createElement("button");
        addBtn.className = "tmdb-button";
        addBtn.type = "button";
        addBtn.textContent = isMovie
          ? "Add movie to library"
          : "Add show to library";
        addBtn.addEventListener("click", () => {
          const item = addToLibraryFromTmdbResult(r, isMovie);
          openPlayer(item, { fromRoute: "search" });
        });

        actions.appendChild(addBtn);

        const watchlistBtn = document.createElement("button");
        watchlistBtn.className = "tmdb-button";
        watchlistBtn.type = "button";
        watchlistBtn.textContent = isMovie
          ? "Add movie to watchlist"
          : "Add show to watchlist";
        watchlistBtn.addEventListener("click", () => {
          const item = addToLibraryFromTmdbResult(r, isMovie, {
            makeWatchlist: true
          });
            if (!item.isWatchlist) {
              item.isWatchlist = true;
              saveLibrary();
            }
            renderHome();
            renderLibrary();
            openPlayer(item, { fromRoute: "search" });
          });

        actions.appendChild(watchlistBtn);
        body.appendChild(actions);

        row.appendChild(body);
        tmdbResultsEl.appendChild(row);
      });
    }

    tmdbSearchButton.addEventListener("click", () =>
      searchTmdb(tmdbSearchInput.value)
    );
    tmdbSearchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        searchTmdb(tmdbSearchInput.value);
      }
    });

    /******************************************************************
     * POPULAR FETCH
     ******************************************************************/
    async function loadPopular() {
      if (!TMDB_API_KEY || TMDB_API_KEY === "REPLACE_WITH_YOUR_TMDB_KEY") {
        renderHome();
        return;
      }

      try {
        const [movieRes, tvRes] = await Promise.all([
          fetch(
            `${TMDB_API_BASE}/movie/popular?api_key=${encodeURIComponent(
              TMDB_API_KEY
            )}&language=en-US&region=${encodeURIComponent(REGION)}`
          ),
          fetch(
            `${TMDB_API_BASE}/tv/popular?api_key=${encodeURIComponent(
              TMDB_API_KEY
            )}&language=en-US&region=${encodeURIComponent(REGION)}`
          )
        ]);

        if (movieRes.ok) {
          const m = await movieRes.json();
          popularMovies = m.results || [];
        }
        if (tvRes.ok) {
          const t = await tvRes.json();
          popularTv = t.results || [];
        }
      } catch (e) {
        console.error(e);
      } finally {
        renderHome();
      }
    }

    /******************************************************************
     * INIT
     ******************************************************************/
    function init() {
      detectDevice();
      setupCasting();
      loadLibraryFromStorage();
      renderLibrary();
      renderHome();
      loadPopular();
    }

    init();
  </script>
</body>
</html>
